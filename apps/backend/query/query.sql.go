// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createVendor = `-- name: CreateVendor :one
insert into app.vendor (wallet, name) values ($1, $2) returning pk, id, wallet, name
`

type CreateVendorParams struct {
	Wallet string
	Name   string
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendor, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const createVendorWithUUID = `-- name: CreateVendorWithUUID :one
insert into app.vendor (id, wallet, name) values ($1, $2, $3) returning pk, id, wallet, name
`

type CreateVendorWithUUIDParams struct {
	ID     uuid.UUID
	Wallet string
	Name   string
}

func (q *Queries) CreateVendorWithUUID(ctx context.Context, arg CreateVendorWithUUIDParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendorWithUUID, arg.ID, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const createVenue = `-- name: CreateVenue :one
insert into app.venue (
    name,
    streetaddr,
    zip,
    city,
    state_code,
    state_name,
    country_code,
    country_name,
    num_unique,
    num_ga,
    vendor
) values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) returning (
    name,
    streetaddr,
    zip,
    city,
    state_code,
    country_code,
    country_name,
    num_unique,
    num_ga
)
`

type CreateVenueParams struct {
	Name        string
	Streetaddr  string
	Zip         string
	City        string
	StateCode   string
	StateName   string
	CountryCode string
	CountryName string
	NumUnique   int32
	NumGa       int32
	Vendor      int32
}

func (q *Queries) CreateVenue(ctx context.Context, arg CreateVenueParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, createVenue,
		arg.Name,
		arg.Streetaddr,
		arg.Zip,
		arg.City,
		arg.StateCode,
		arg.StateName,
		arg.CountryCode,
		arg.CountryName,
		arg.NumUnique,
		arg.NumGa,
		arg.Vendor,
	)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getVendorByUuid = `-- name: GetVendorByUuid :one
select pk, id, wallet, name from app.vendor where id = $1 limit 1
`

func (q *Queries) GetVendorByUuid(ctx context.Context, id uuid.UUID) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByUuid, id)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getVendorByWallet = `-- name: GetVendorByWallet :one
select pk, id, wallet, name from app.vendor where wallet = $1 limit 1
`

func (q *Queries) GetVendorByWallet(ctx context.Context, wallet string) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByWallet, wallet)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const updateVendorName = `-- name: UpdateVendorName :one
update app.vendor set name = $2 where wallet = $1 returning pk, id, wallet, name
`

type UpdateVendorNameParams struct {
	Wallet string
	Name   string
}

func (q *Queries) UpdateVendorName(ctx context.Context, arg UpdateVendorNameParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, updateVendorName, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const userGetEventsPaginated = `-- name: UserGetEventsPaginated :many
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo from app.event event
where event.venue in (
    select pk from app.venue venue
    where (2::text = '' or venue.zip = $2::text)
)
and ($3::text = '' or event.name = $3::text)
and ($4::text = '' or event.type = $4::text)
and (event.basecost <= $5::double precision)
and (event.event_datetime >= $6::timestamp)
limit 5
offset (($1::int - 1) * 5)
`

type UserGetEventsPaginatedParams struct {
	Column1 int32
	Column2 string
	Column3 string
	Column4 string
	Column5 float64
	Column6 pgtype.Timestamp
}

func (q *Queries) UserGetEventsPaginated(ctx context.Context, arg UserGetEventsPaginatedParams) ([]AppEvent, error) {
	rows, err := q.db.Query(ctx, userGetEventsPaginated,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppEvent
	for rows.Next() {
		var i AppEvent
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Venue,
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Description,
			&i.Disclaimer,
			&i.Basecost,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorGetEventsPaginated = `-- name: VendorGetEventsPaginated :many
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo from app.event event
where event.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2::varchar(40)
)
and ($3::int = -1 or $3::int = event.venue)
limit 5
offset (($1::int - 1) * 5)
`

type VendorGetEventsPaginatedParams struct {
	Column1 int32
	Column2 string
	Column3 int32
}

func (q *Queries) VendorGetEventsPaginated(ctx context.Context, arg VendorGetEventsPaginatedParams) ([]AppEvent, error) {
	rows, err := q.db.Query(ctx, vendorGetEventsPaginated, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppEvent
	for rows.Next() {
		var i AppEvent
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Venue,
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Description,
			&i.Disclaimer,
			&i.Basecost,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorGetVenuesPaginated = `-- name: VendorGetVenuesPaginated :many
select pk, id, vendor, name, streetaddr, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue venue
where venue.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2
)
limit 5
offset (($1::int - 1) * 5)
`

type VendorGetVenuesPaginatedParams struct {
	Column1 int32
	Wallet  string
}

func (q *Queries) VendorGetVenuesPaginated(ctx context.Context, arg VendorGetVenuesPaginatedParams) ([]AppVenue, error) {
	rows, err := q.db.Query(ctx, vendorGetVenuesPaginated, arg.Column1, arg.Wallet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppVenue
	for rows.Next() {
		var i AppVenue
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Name,
			&i.Streetaddr,
			&i.Zip,
			&i.City,
			&i.StateCode,
			&i.StateName,
			&i.CountryCode,
			&i.CountryName,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

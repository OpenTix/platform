// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createVendor = `-- name: CreateVendor :one
insert into app.vendor (wallet, name) values ($1, $2) returning pk, id, wallet, name
`

type CreateVendorParams struct {
	Wallet string
	Name   string
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendor, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const createVendorWithUUID = `-- name: CreateVendorWithUUID :one
insert into app.vendor (id, wallet, name) values ($1, $2, $3) returning pk, id, wallet, name
`

type CreateVendorWithUUIDParams struct {
	ID     uuid.UUID
	Wallet string
	Name   string
}

func (q *Queries) CreateVendorWithUUID(ctx context.Context, arg CreateVendorWithUUIDParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendorWithUUID, arg.ID, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const createVenue = `-- name: CreateVenue :one
insert into app.venue (
    name,
    streetaddr,
    zip,
    city,
    state_code,
    state_name,
    country_code,
    country_name,
    num_unique,
    num_ga,
    vendor
) values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) returning (
    name,
    streetaddr,
    zip,
    city,
    state_code,
    country_code,
    country_name,
    num_unique,
    num_ga
)
`

type CreateVenueParams struct {
	Name        string
	Streetaddr  string
	Zip         string
	City        string
	StateCode   string
	StateName   string
	CountryCode string
	CountryName string
	NumUnique   int32
	NumGa       int32
	Vendor      int32
}

func (q *Queries) CreateVenue(ctx context.Context, arg CreateVenueParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, createVenue,
		arg.Name,
		arg.Streetaddr,
		arg.Zip,
		arg.City,
		arg.StateCode,
		arg.StateName,
		arg.CountryCode,
		arg.CountryName,
		arg.NumUnique,
		arg.NumGa,
		arg.Vendor,
	)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getVendorByUuid = `-- name: GetVendorByUuid :one
select pk, id, wallet, name from app.vendor where id = $1 limit 1
`

func (q *Queries) GetVendorByUuid(ctx context.Context, id uuid.UUID) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByUuid, id)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getVendorByWallet = `-- name: GetVendorByWallet :one
select pk, id, wallet, name from app.vendor where wallet = $1 limit 1
`

func (q *Queries) GetVendorByWallet(ctx context.Context, wallet string) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByWallet, wallet)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const updateVendorName = `-- name: UpdateVendorName :one
update app.vendor set name = $2 where wallet = $1 returning pk, id, wallet, name
`

type UpdateVendorNameParams struct {
	Wallet string
	Name   string
}

func (q *Queries) UpdateVendorName(ctx context.Context, arg UpdateVendorNameParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, updateVendorName, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const userGetEventsPaginated = `-- name: UserGetEventsPaginated :many
select event.pk, event.id, event.vendor, venue, event.name, type, event_datetime, description, disclaimer, basecost, event.num_unique, event.num_ga, event.photo, venue.pk, venue.id, venue.vendor, venue.name, streetaddr, zip, city, state_code, state_name, country_code, country_name, venue.num_unique, venue.num_ga, venue.photo, event.pk, event.id, event.vendor, venue, event.name, type, event_datetime, description, disclaimer, basecost, event.num_unique, event.num_ga, event.photo, venue.pk, venue.id, venue.vendor, venue.name, streetaddr, zip, city, state_code, state_name, country_code, country_name, venue.num_unique, venue.num_ga, venue.photo
from app.event event, app.venue venue
where event.venue = venue.pk
and ($2::text = '' or $2::text = venue.zip)
and ($3::text = '' or $3::text = event.name)
and ($4::text = '' or $4::text = event.type)
and ($5::double precision >= event.basecost)
and ($6::timestamp <= event.event_datetime)
limit 5
offset (($1::int - 1) * 5)
`

type UserGetEventsPaginatedParams struct {
	Column1 int32
	Column2 string
	Column3 string
	Column4 string
	Column5 float64
	Column6 pgtype.Timestamp
}

type UserGetEventsPaginatedRow struct {
	Pk              int32
	ID              uuid.UUID
	Vendor          int32
	Venue           int32
	Name            string
	Type            string
	EventDatetime   pgtype.Timestamp
	Description     string
	Disclaimer      pgtype.Text
	Basecost        float64
	NumUnique       int32
	NumGa           int32
	Photo           pgtype.Text
	Pk_2            int32
	ID_2            uuid.UUID
	Vendor_2        int32
	Name_2          string
	Streetaddr      string
	Zip             string
	City            string
	StateCode       string
	StateName       string
	CountryCode     string
	CountryName     string
	NumUnique_2     int32
	NumGa_2         int32
	Photo_2         pgtype.Text
	Pk_3            int32
	ID_3            uuid.UUID
	Vendor_3        int32
	Venue_2         int32
	Name_3          string
	Type_2          string
	EventDatetime_2 pgtype.Timestamp
	Description_2   string
	Disclaimer_2    pgtype.Text
	Basecost_2      float64
	NumUnique_3     int32
	NumGa_3         int32
	Photo_3         pgtype.Text
	Pk_4            int32
	ID_4            uuid.UUID
	Vendor_4        int32
	Name_4          string
	Streetaddr_2    string
	Zip_2           string
	City_2          string
	StateCode_2     string
	StateName_2     string
	CountryCode_2   string
	CountryName_2   string
	NumUnique_4     int32
	NumGa_4         int32
	Photo_4         pgtype.Text
}

// select * from app.event event
// where exists (
//
//	select * from app.venue venue
//	where ($2::text = '' or venue.zip = $2::text)
//
// )
// and ($3::text = ” or event.name = $3::text)
// and ($4::text = ” or event.type = $4::text)
// and (event.basecost <= $5::double precision)
// and (event.event_datetime >= $6::timestamp)
// limit 5
// offset (($1::int - 1) * 5);
func (q *Queries) UserGetEventsPaginated(ctx context.Context, arg UserGetEventsPaginatedParams) ([]UserGetEventsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, userGetEventsPaginated,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserGetEventsPaginatedRow
	for rows.Next() {
		var i UserGetEventsPaginatedRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Venue,
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Description,
			&i.Disclaimer,
			&i.Basecost,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
			&i.Pk_2,
			&i.ID_2,
			&i.Vendor_2,
			&i.Name_2,
			&i.Streetaddr,
			&i.Zip,
			&i.City,
			&i.StateCode,
			&i.StateName,
			&i.CountryCode,
			&i.CountryName,
			&i.NumUnique_2,
			&i.NumGa_2,
			&i.Photo_2,
			&i.Pk_3,
			&i.ID_3,
			&i.Vendor_3,
			&i.Venue_2,
			&i.Name_3,
			&i.Type_2,
			&i.EventDatetime_2,
			&i.Description_2,
			&i.Disclaimer_2,
			&i.Basecost_2,
			&i.NumUnique_3,
			&i.NumGa_3,
			&i.Photo_3,
			&i.Pk_4,
			&i.ID_4,
			&i.Vendor_4,
			&i.Name_4,
			&i.Streetaddr_2,
			&i.Zip_2,
			&i.City_2,
			&i.StateCode_2,
			&i.StateName_2,
			&i.CountryCode_2,
			&i.CountryName_2,
			&i.NumUnique_4,
			&i.NumGa_4,
			&i.Photo_4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorGetEventsPaginated = `-- name: VendorGetEventsPaginated :many
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo from app.event event
where event.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2
)
and ($3::int = -1 or $3::int = event.venue)
limit 5
offset (($1::int - 1) * 5)
`

type VendorGetEventsPaginatedParams struct {
	Column1 int32
	Wallet  string
	Column3 int32
}

func (q *Queries) VendorGetEventsPaginated(ctx context.Context, arg VendorGetEventsPaginatedParams) ([]AppEvent, error) {
	rows, err := q.db.Query(ctx, vendorGetEventsPaginated, arg.Column1, arg.Wallet, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppEvent
	for rows.Next() {
		var i AppEvent
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Venue,
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Description,
			&i.Disclaimer,
			&i.Basecost,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorGetVenuesPaginated = `-- name: VendorGetVenuesPaginated :many
select pk, id, vendor, name, streetaddr, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue venue
where venue.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2
)
limit 5
offset (($1::int - 1) * 5)
`

type VendorGetVenuesPaginatedParams struct {
	Column1 int32
	Wallet  string
}

func (q *Queries) VendorGetVenuesPaginated(ctx context.Context, arg VendorGetVenuesPaginatedParams) ([]AppVenue, error) {
	rows, err := q.db.Query(ctx, vendorGetVenuesPaginated, arg.Column1, arg.Wallet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppVenue
	for rows.Next() {
		var i AppVenue
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Name,
			&i.Streetaddr,
			&i.Zip,
			&i.City,
			&i.StateCode,
			&i.StateName,
			&i.CountryCode,
			&i.CountryName,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

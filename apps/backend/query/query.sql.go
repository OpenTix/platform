// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const createVendor = `-- name: CreateVendor :one
insert into app.vendor (wallet, name) values ($1, $2) returning pk, id, wallet, name
`

type CreateVendorParams struct {
	Wallet string
	Name   string
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendor, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getEventsPaginated = `-- name: GetEventsPaginated :many
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo from app.event event
where exists (
    select pk, id, vendor, name, streetaddr, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue venue
    where (case when $2 then venue.zip = $2 else true end)
)
and (case when $3 then event.name = $3 else true end)
and (case when $4 then event.type = $4 else true end)
and (case when $5 then event.basecost <= $5 else true end)
and (case when $6 then event.event_datetime >= $6 else true end)
limit 5
offset (($1::int - 1) * 5)
`

type GetEventsPaginatedParams struct {
	Column1 int32
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
	Column6 interface{}
}

func (q *Queries) GetEventsPaginated(ctx context.Context, arg GetEventsPaginatedParams) ([]AppEvent, error) {
	rows, err := q.db.Query(ctx, getEventsPaginated,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppEvent
	for rows.Next() {
		var i AppEvent
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Venue,
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Description,
			&i.Disclaimer,
			&i.Basecost,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVendorByUuid = `-- name: GetVendorByUuid :one
select pk, id, wallet, name from app.vendor where id = $1 limit 1
`

func (q *Queries) GetVendorByUuid(ctx context.Context, id uuid.UUID) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByUuid, id)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getVendorByWallet = `-- name: GetVendorByWallet :one
select pk, id, wallet, name from app.vendor where wallet = $1 limit 1
`

func (q *Queries) GetVendorByWallet(ctx context.Context, wallet string) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByWallet, wallet)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getVenuesPaginated = `-- name: GetVenuesPaginated :many
select pk, id, vendor, name, streetaddr, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue venue
where venue.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2
)
limit 5
offset (($1::int - 1) * 5)
`

type GetVenuesPaginatedParams struct {
	Column1 int32
	Wallet  string
}

func (q *Queries) GetVenuesPaginated(ctx context.Context, arg GetVenuesPaginatedParams) ([]AppVenue, error) {
	rows, err := q.db.Query(ctx, getVenuesPaginated, arg.Column1, arg.Wallet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppVenue
	for rows.Next() {
		var i AppVenue
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Name,
			&i.Streetaddr,
			&i.Zip,
			&i.City,
			&i.StateCode,
			&i.StateName,
			&i.CountryCode,
			&i.CountryName,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVendorName = `-- name: UpdateVendorName :one
update app.vendor set name = $2 where wallet = $1 returning pk, id, wallet, name
`

type UpdateVendorNameParams struct {
	Wallet string
	Name   string
}

func (q *Queries) UpdateVendorName(ctx context.Context, arg UpdateVendorNameParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, updateVendorName, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

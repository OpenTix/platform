// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package query

import (
	"context"

	"github.com/google/uuid"
)

const createVendor = `-- name: CreateVendor :one
insert into app.vendor (wallet, name) values ($1, $2) returning pk, id, wallet, name
`

type CreateVendorParams struct {
	Wallet string
	Name   string
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendor, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const createVenue = `-- name: CreateVenue :one
insert into app.venue (
    name,
    streetaddr,
    zip,
    city,
    state_code,
    state_name,
    country_code,
    country_name,
    num_unique,
    num_ga,
    vendor
) values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) returning pk, id, vendor, name, streetaddr, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo
`

type CreateVenueParams struct {
	Name        string
	Streetaddr  string
	Zip         string
	City        string
	StateCode   string
	StateName   string
	CountryCode string
	CountryName string
	NumUnique   int32
	NumGa       int32
	Vendor      int32
}

func (q *Queries) CreateVenue(ctx context.Context, arg CreateVenueParams) (AppVenue, error) {
	row := q.db.QueryRow(ctx, createVenue,
		arg.Name,
		arg.Streetaddr,
		arg.Zip,
		arg.City,
		arg.StateCode,
		arg.StateName,
		arg.CountryCode,
		arg.CountryName,
		arg.NumUnique,
		arg.NumGa,
		arg.Vendor,
	)
	var i AppVenue
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Name,
		&i.Streetaddr,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.StateName,
		&i.CountryCode,
		&i.CountryName,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
	)
	return i, err
}

const getEventsPaginated = `-- name: GetEventsPaginated :many
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo from app.event event
where exists (
    select pk, id, vendor, name, streetaddr, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue venue
    where ($2 is null or venue.zip = $2)
)
and ($3 is null or event.name = $3)
and ($4 is null or event.type = $4)
and ($5 is null or event.basecost <= $5)
and ($6 is null or event.event_datetime >= $6)
limit 5
offset (($1::int - 1) * 5)
`

type GetEventsPaginatedParams struct {
	Column1 int32
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
	Column6 interface{}
}

// select * from app.event event
// where exists (
//
//	select * from app.venue venue
//	where (case when $2 then venue.zip = $2 else true end)
//
// )
// and (case when $3 then event.name = $3 else true end)
// and (case when $4 then event.type = $4 else true end)
// and (case when $5 then event.basecost <= $5 else true end)
// and (case when $6 then event.event_datetime >= $6 else true end)
// limit 5
// offset (($1::int - 1) * 5);
// select * from app.event event
// where exists (
//
//	select * from app.venue venue
//	where (sqlc.narg('zip') is null or venue.zip = sqlc.narg('zip'))
//
// )
// and (sqlc.narg('name') is null or event.name = sqlc.narg('name'))
// and (sqlc.narg('type') is null or event.type = sqlc.narg('type'))
// and (sqlc.narg('basecost') is null or event.basecost <= sqlc.narg('basecost'))
// and (sqlc.narg('datetime') is null or event.event_datetime >= sqlc.narg('datetime'))
// limit 5
// offset (($1::int - 1) * 5);
func (q *Queries) GetEventsPaginated(ctx context.Context, arg GetEventsPaginatedParams) ([]AppEvent, error) {
	rows, err := q.db.Query(ctx, getEventsPaginated,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppEvent
	for rows.Next() {
		var i AppEvent
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Venue,
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Description,
			&i.Disclaimer,
			&i.Basecost,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVendorByUuid = `-- name: GetVendorByUuid :one
select pk, id, wallet, name from app.vendor where id = $1 limit 1
`

func (q *Queries) GetVendorByUuid(ctx context.Context, id uuid.UUID) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByUuid, id)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getVendorByWallet = `-- name: GetVendorByWallet :one
select pk, id, wallet, name from app.vendor where wallet = $1 limit 1
`

func (q *Queries) GetVendorByWallet(ctx context.Context, wallet string) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByWallet, wallet)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getVenuesPaginated = `-- name: GetVenuesPaginated :many
select pk, id, vendor, name, streetaddr, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue venue
where venue.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2
)
limit 5
offset (($1::int - 1) * 5)
`

type GetVenuesPaginatedParams struct {
	Column1 int32
	Wallet  string
}

func (q *Queries) GetVenuesPaginated(ctx context.Context, arg GetVenuesPaginatedParams) ([]AppVenue, error) {
	rows, err := q.db.Query(ctx, getVenuesPaginated, arg.Column1, arg.Wallet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppVenue
	for rows.Next() {
		var i AppVenue
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Name,
			&i.Streetaddr,
			&i.Zip,
			&i.City,
			&i.StateCode,
			&i.StateName,
			&i.CountryCode,
			&i.CountryName,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVendorName = `-- name: UpdateVendorName :one
update app.vendor set name = $2 where wallet = $1 returning pk, id, wallet, name
`

type UpdateVendorNameParams struct {
	Wallet string
	Name   string
}

func (q *Queries) UpdateVendorName(ctx context.Context, arg UpdateVendorNameParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, updateVendorName, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package query

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addTicket = `-- name: AddTicket :one
insert into app.ticket (
    event,
    contract,
    ticket_id
) values (
    $1, $2, $3
) returning pk, contract, ticket_id, checked_in, event
`

type AddTicketParams struct {
	Event    int32
	Contract string
	TicketID int32
}

func (q *Queries) AddTicket(ctx context.Context, arg AddTicketParams) (AppTicket, error) {
	row := q.db.QueryRow(ctx, addTicket, arg.Event, arg.Contract, arg.TicketID)
	var i AppTicket
	err := row.Scan(
		&i.Pk,
		&i.Contract,
		&i.TicketID,
		&i.CheckedIn,
		&i.Event,
	)
	return i, err
}

const checkVenueVendorStatus = `-- name: CheckVenueVendorStatus :one
select vendor from app.venue
where pk = $1::int
`

func (q *Queries) CheckVenueVendorStatus(ctx context.Context, dollar_1 int32) (int32, error) {
	row := q.db.QueryRow(ctx, checkVenueVendorStatus, dollar_1)
	var vendor int32
	err := row.Scan(&vendor)
	return vendor, err
}

const createEvent = `-- name: CreateEvent :one
insert into app.event (
    vendor,
    venue,
    name,
    type,
    event_datetime,
    description,
    disclaimer,
    basecost,
    num_unique,
    num_ga
) values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) returning (
    name,
    type,
    event_datetime,
    description,
    disclaimer,
    basecost,
    num_unique,
    num_ga
)
`

type CreateEventParams struct {
	Vendor        int32
	Venue         int32
	Name          string
	Type          string
	EventDatetime pgtype.Timestamp
	Description   string
	Disclaimer    pgtype.Text
	Basecost      float64
	NumUnique     int32
	NumGa         int32
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Vendor,
		arg.Venue,
		arg.Name,
		arg.Type,
		arg.EventDatetime,
		arg.Description,
		arg.Disclaimer,
		arg.Basecost,
		arg.NumUnique,
		arg.NumGa,
	)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const createVendor = `-- name: CreateVendor :one
insert into app.vendor (wallet, name) values ($1, $2) returning pk, id, wallet, name
`

type CreateVendorParams struct {
	Wallet string
	Name   string
}

func (q *Queries) CreateVendor(ctx context.Context, arg CreateVendorParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendor, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const createVendorWithUUID = `-- name: CreateVendorWithUUID :one
insert into app.vendor (id, wallet, name) values ($1, $2, $3) returning pk, id, wallet, name
`

type CreateVendorWithUUIDParams struct {
	ID     uuid.UUID
	Wallet string
	Name   string
}

func (q *Queries) CreateVendorWithUUID(ctx context.Context, arg CreateVendorWithUUIDParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, createVendorWithUUID, arg.ID, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const createVenue = `-- name: CreateVenue :one
insert into app.venue (
    name,
    street_address,
    zip,
    city,
    state_code,
    state_name,
    country_code,
    country_name,
    num_unique,
    num_ga,
    vendor
) values (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) returning (
    name,
    street_address,
    zip,
    city,
    state_code,
    country_code,
    country_name,
    num_unique,
    num_ga
)
`

type CreateVenueParams struct {
	Name          string
	StreetAddress string
	Zip           string
	City          string
	StateCode     string
	StateName     string
	CountryCode   string
	CountryName   string
	NumUnique     int32
	NumGa         int32
	Vendor        int32
}

func (q *Queries) CreateVenue(ctx context.Context, arg CreateVenueParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, createVenue,
		arg.Name,
		arg.StreetAddress,
		arg.Zip,
		arg.City,
		arg.StateCode,
		arg.StateName,
		arg.CountryCode,
		arg.CountryName,
		arg.NumUnique,
		arg.NumGa,
		arg.Vendor,
	)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}

const getTicket = `-- name: GetTicket :one
select pk, contract, ticket_id, checked_in, event from app.ticket where event = $1 and ticket_id = $2 limit 1
`

type GetTicketParams struct {
	Event    int32
	TicketID int32
}

func (q *Queries) GetTicket(ctx context.Context, arg GetTicketParams) (AppTicket, error) {
	row := q.db.QueryRow(ctx, getTicket, arg.Event, arg.TicketID)
	var i AppTicket
	err := row.Scan(
		&i.Pk,
		&i.Contract,
		&i.TicketID,
		&i.CheckedIn,
		&i.Event,
	)
	return i, err
}

const getTicketsByEvent = `-- name: GetTicketsByEvent :many
select pk, contract, ticket_id, checked_in, event from app.ticket where event = $1
`

func (q *Queries) GetTicketsByEvent(ctx context.Context, event int32) ([]AppTicket, error) {
	rows, err := q.db.Query(ctx, getTicketsByEvent, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppTicket
	for rows.Next() {
		var i AppTicket
		if err := rows.Scan(
			&i.Pk,
			&i.Contract,
			&i.TicketID,
			&i.CheckedIn,
			&i.Event,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVendorByUuid = `-- name: GetVendorByUuid :one
select pk, id, wallet, name from app.vendor where id = $1 limit 1
`

func (q *Queries) GetVendorByUuid(ctx context.Context, id uuid.UUID) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByUuid, id)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const getVendorByWallet = `-- name: GetVendorByWallet :one
select pk, id, wallet, name from app.vendor where wallet = $1 limit 1
`

func (q *Queries) GetVendorByWallet(ctx context.Context, wallet string) (AppVendor, error) {
	row := q.db.QueryRow(ctx, getVendorByWallet, wallet)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const insecureRemoveEventPhoto = `-- name: InsecureRemoveEventPhoto :one
update app.event
set photo = null
where event.id = $1
returning pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash
`

func (q *Queries) InsecureRemoveEventPhoto(ctx context.Context, id uuid.UUID) (AppEvent, error) {
	row := q.db.QueryRow(ctx, insecureRemoveEventPhoto, id)
	var i AppEvent
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Venue,
		&i.Name,
		&i.Type,
		&i.EventDatetime,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
		&i.TransactionHash,
	)
	return i, err
}

const insecureRemoveVenuePhoto = `-- name: InsecureRemoveVenuePhoto :one
update app.venue
set photo = null
where venue.id = $1
returning pk, id, vendor, name, street_address, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo
`

func (q *Queries) InsecureRemoveVenuePhoto(ctx context.Context, id uuid.UUID) (AppVenue, error) {
	row := q.db.QueryRow(ctx, insecureRemoveVenuePhoto, id)
	var i AppVenue
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Name,
		&i.StreetAddress,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.StateName,
		&i.CountryCode,
		&i.CountryName,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
	)
	return i, err
}

const insecureUpdateEventPhoto = `-- name: InsecureUpdateEventPhoto :one
update app.event
set photo = $2
where event.id = $1
returning pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash
`

type InsecureUpdateEventPhotoParams struct {
	ID    uuid.UUID
	Photo pgtype.Text
}

func (q *Queries) InsecureUpdateEventPhoto(ctx context.Context, arg InsecureUpdateEventPhotoParams) (AppEvent, error) {
	row := q.db.QueryRow(ctx, insecureUpdateEventPhoto, arg.ID, arg.Photo)
	var i AppEvent
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Venue,
		&i.Name,
		&i.Type,
		&i.EventDatetime,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
		&i.TransactionHash,
	)
	return i, err
}

const insecureUpdateVenuePhoto = `-- name: InsecureUpdateVenuePhoto :one
update app.venue
set photo = $2
where venue.id = $1
returning pk, id, vendor, name, street_address, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo
`

type InsecureUpdateVenuePhotoParams struct {
	ID    uuid.UUID
	Photo pgtype.Text
}

func (q *Queries) InsecureUpdateVenuePhoto(ctx context.Context, arg InsecureUpdateVenuePhotoParams) (AppVenue, error) {
	row := q.db.QueryRow(ctx, insecureUpdateVenuePhoto, arg.ID, arg.Photo)
	var i AppVenue
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Name,
		&i.StreetAddress,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.StateName,
		&i.CountryCode,
		&i.CountryName,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
	)
	return i, err
}

const updateCheckin = `-- name: UpdateCheckin :one
update app.ticket set checked_in = $2 where pk = $1 returning pk, contract, ticket_id, checked_in, event
`

type UpdateCheckinParams struct {
	Pk        int32
	CheckedIn bool
}

func (q *Queries) UpdateCheckin(ctx context.Context, arg UpdateCheckinParams) (AppTicket, error) {
	row := q.db.QueryRow(ctx, updateCheckin, arg.Pk, arg.CheckedIn)
	var i AppTicket
	err := row.Scan(
		&i.Pk,
		&i.Contract,
		&i.TicketID,
		&i.CheckedIn,
		&i.Event,
	)
	return i, err
}

const updateVendorName = `-- name: UpdateVendorName :one
update app.vendor set name = $2 where wallet = $1 returning pk, id, wallet, name
`

type UpdateVendorNameParams struct {
	Wallet string
	Name   string
}

func (q *Queries) UpdateVendorName(ctx context.Context, arg UpdateVendorNameParams) (AppVendor, error) {
	row := q.db.QueryRow(ctx, updateVendorName, arg.Wallet, arg.Name)
	var i AppVendor
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Wallet,
		&i.Name,
	)
	return i, err
}

const userGetEventByUuid = `-- name: UserGetEventByUuid :one
select event.name Eventname, event.type, event.event_datetime,
event.id, event.description, event.disclaimer,
event.basecost, event.num_unique, event.num_ga,
event.photo Eventphoto, venue.name Venuename, venue.street_address, venue.zip, venue.city,
venue.state_code, venue.country_code, venue.country_name,
venue.photo Venuephoto, vendor.name Vendorname
from app.event event, app.venue venue, app.vendor vendor
where event.id = $1
and event.venue = venue.pk
and event.vendor = vendor.pk
limit 1
`

type UserGetEventByUuidRow struct {
	Eventname     string
	Type          string
	EventDatetime pgtype.Timestamp
	ID            uuid.UUID
	Description   string
	Disclaimer    pgtype.Text
	Basecost      float64
	NumUnique     int32
	NumGa         int32
	Eventphoto    pgtype.Text
	Venuename     string
	StreetAddress string
	Zip           string
	City          string
	StateCode     string
	CountryCode   string
	CountryName   string
	Venuephoto    pgtype.Text
	Vendorname    string
}

func (q *Queries) UserGetEventByUuid(ctx context.Context, id uuid.UUID) (UserGetEventByUuidRow, error) {
	row := q.db.QueryRow(ctx, userGetEventByUuid, id)
	var i UserGetEventByUuidRow
	err := row.Scan(
		&i.Eventname,
		&i.Type,
		&i.EventDatetime,
		&i.ID,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Eventphoto,
		&i.Venuename,
		&i.StreetAddress,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.CountryCode,
		&i.CountryName,
		&i.Venuephoto,
		&i.Vendorname,
	)
	return i, err
}

const userGetEventsPaginated = `-- name: UserGetEventsPaginated :many
select event.name, event.type, event.event_datetime,
venue.name Venuename, venue.state_code, venue.country_code, event.photo,
event.id
from app.event event, app.venue venue
where event.venue = venue.pk
and ($2::text = '' or $2::text = venue.zip)
and ($3::text = '' or $3::text = event.name)
and ($4::text = '' or $4::text = event.type)
and ($5::double precision >= event.basecost)
and ($6::timestamp <= event.event_datetime)
order by event.event_datetime, event.name
limit 5
offset (($1::int - 1) * 5)
`

type UserGetEventsPaginatedParams struct {
	Column1 int32
	Column2 string
	Column3 string
	Column4 string
	Column5 float64
	Column6 pgtype.Timestamp
}

type UserGetEventsPaginatedRow struct {
	Name          string
	Type          string
	EventDatetime pgtype.Timestamp
	Venuename     string
	StateCode     string
	CountryCode   string
	Photo         pgtype.Text
	ID            uuid.UUID
}

func (q *Queries) UserGetEventsPaginated(ctx context.Context, arg UserGetEventsPaginatedParams) ([]UserGetEventsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, userGetEventsPaginated,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserGetEventsPaginatedRow
	for rows.Next() {
		var i UserGetEventsPaginatedRow
		if err := rows.Scan(
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Venuename,
			&i.StateCode,
			&i.CountryCode,
			&i.Photo,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorAddTransactionHash = `-- name: VendorAddTransactionHash :one
update app.event set transaction_hash = $3 
where event.pk = $1 
and event.vendor = (
    select pk from app.vendor 
    where wallet = $2
) 
returning pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash
`

type VendorAddTransactionHashParams struct {
	Pk              int32
	Wallet          string
	TransactionHash pgtype.Text
}

func (q *Queries) VendorAddTransactionHash(ctx context.Context, arg VendorAddTransactionHashParams) (AppEvent, error) {
	row := q.db.QueryRow(ctx, vendorAddTransactionHash, arg.Pk, arg.Wallet, arg.TransactionHash)
	var i AppEvent
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Venue,
		&i.Name,
		&i.Type,
		&i.EventDatetime,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
		&i.TransactionHash,
	)
	return i, err
}

const vendorGetAllVenues = `-- name: VendorGetAllVenues :many
select venue.pk, venue.id, venue.name from app.venue
where venue.vendor = (
    select pk from app.vendor
    where wallet = $1
)
order by venue.name
`

type VendorGetAllVenuesRow struct {
	Pk   int32
	ID   uuid.UUID
	Name string
}

func (q *Queries) VendorGetAllVenues(ctx context.Context, wallet string) ([]VendorGetAllVenuesRow, error) {
	rows, err := q.db.Query(ctx, vendorGetAllVenues, wallet)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VendorGetAllVenuesRow
	for rows.Next() {
		var i VendorGetAllVenuesRow
		if err := rows.Scan(&i.Pk, &i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorGetEventByPk = `-- name: VendorGetEventByPk :one
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash from app.event event
where event.pk = $1
and event.vendor = (
    select pk from app.vendor
    where wallet = $2
)
limit 1
`

type VendorGetEventByPkParams struct {
	Pk     int32
	Wallet string
}

func (q *Queries) VendorGetEventByPk(ctx context.Context, arg VendorGetEventByPkParams) (AppEvent, error) {
	row := q.db.QueryRow(ctx, vendorGetEventByPk, arg.Pk, arg.Wallet)
	var i AppEvent
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Venue,
		&i.Name,
		&i.Type,
		&i.EventDatetime,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
		&i.TransactionHash,
	)
	return i, err
}

const vendorGetEventByUuid = `-- name: VendorGetEventByUuid :one
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash from app.event event
where event.id = $1
and event.vendor = (
    select pk from app.vendor
    where wallet = $2
)
limit 1
`

type VendorGetEventByUuidParams struct {
	ID     uuid.UUID
	Wallet string
}

func (q *Queries) VendorGetEventByUuid(ctx context.Context, arg VendorGetEventByUuidParams) (AppEvent, error) {
	row := q.db.QueryRow(ctx, vendorGetEventByUuid, arg.ID, arg.Wallet)
	var i AppEvent
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Venue,
		&i.Name,
		&i.Type,
		&i.EventDatetime,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
		&i.TransactionHash,
	)
	return i, err
}

const vendorGetEventsPaginated = `-- name: VendorGetEventsPaginated :many
select pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash from app.event event
where event.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2
)
and ($3::int = -1 or $3::int = event.venue)
and ($4::timestamp <= event.event_datetime)
and ($5::text = '' or $5::text like LOWER(event.name) or $5::text like LOWER(event.type))
order by event.event_datetime, event.name
limit 25
offset (($1::int - 1) * 25)
`

type VendorGetEventsPaginatedParams struct {
	Column1 int32
	Wallet  string
	Column3 int32
	Column4 pgtype.Timestamp
	Column5 string
}

func (q *Queries) VendorGetEventsPaginated(ctx context.Context, arg VendorGetEventsPaginatedParams) ([]AppEvent, error) {
	rows, err := q.db.Query(ctx, vendorGetEventsPaginated,
		arg.Column1,
		arg.Wallet,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppEvent
	for rows.Next() {
		var i AppEvent
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Venue,
			&i.Name,
			&i.Type,
			&i.EventDatetime,
			&i.Description,
			&i.Disclaimer,
			&i.Basecost,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
			&i.TransactionHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorGetVenueByPk = `-- name: VendorGetVenueByPk :one
select pk, id, vendor, name, street_address, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue 
where venue.pk = $1 
and venue.vendor = (
    select pk from app.vendor
    where wallet = $2
)
limit 1
`

type VendorGetVenueByPkParams struct {
	Pk     int32
	Wallet string
}

func (q *Queries) VendorGetVenueByPk(ctx context.Context, arg VendorGetVenueByPkParams) (AppVenue, error) {
	row := q.db.QueryRow(ctx, vendorGetVenueByPk, arg.Pk, arg.Wallet)
	var i AppVenue
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Name,
		&i.StreetAddress,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.StateName,
		&i.CountryCode,
		&i.CountryName,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
	)
	return i, err
}

const vendorGetVenueByUuid = `-- name: VendorGetVenueByUuid :one
select pk, id, vendor, name, street_address, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue 
where venue.id = $1 
and venue.vendor = (
    select pk from app.vendor
    where wallet = $2
)
limit 1
`

type VendorGetVenueByUuidParams struct {
	ID     uuid.UUID
	Wallet string
}

func (q *Queries) VendorGetVenueByUuid(ctx context.Context, arg VendorGetVenueByUuidParams) (AppVenue, error) {
	row := q.db.QueryRow(ctx, vendorGetVenueByUuid, arg.ID, arg.Wallet)
	var i AppVenue
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Name,
		&i.StreetAddress,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.StateName,
		&i.CountryCode,
		&i.CountryName,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
	)
	return i, err
}

const vendorGetVenuesPaginated = `-- name: VendorGetVenuesPaginated :many
select pk, id, vendor, name, street_address, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo from app.venue venue
where venue.vendor = (
    select pk from app.vendor vendor
    where vendor.wallet = $2
)
and ($3::text = '' or $3::text like LOWER(venue.name) or $3::text like LOWER(venue.zip) or $3::text like LOWER(venue.city))
order by venue.name
limit 25
offset (($1::int - 1) * 25)
`

type VendorGetVenuesPaginatedParams struct {
	Column1 int32
	Wallet  string
	Column3 string
}

func (q *Queries) VendorGetVenuesPaginated(ctx context.Context, arg VendorGetVenuesPaginatedParams) ([]AppVenue, error) {
	rows, err := q.db.Query(ctx, vendorGetVenuesPaginated, arg.Column1, arg.Wallet, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppVenue
	for rows.Next() {
		var i AppVenue
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.Vendor,
			&i.Name,
			&i.StreetAddress,
			&i.Zip,
			&i.City,
			&i.StateCode,
			&i.StateName,
			&i.CountryCode,
			&i.CountryName,
			&i.NumUnique,
			&i.NumGa,
			&i.Photo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const vendorPatchEvent = `-- name: VendorPatchEvent :one
update app.event
set
  name = coalesce(nullif($3::text, ''), name),
  type = coalesce(nullif($4::text, ''), type),
  event_datetime = coalesce($5::timestamp, event_datetime),
  description = coalesce(nullif($6::text, ''), description),
  disclaimer = coalesce(nullif($7::text, ''), disclaimer),
  photo = coalesce(nullif($8::text, ''), photo),
  transaction_hash = coalesce(nullif($9::text, ''), transaction_hash)
where event.pk = $1
  and event.vendor = (
    select pk from app.vendor
    where wallet = $2
  )
returning pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash
`

type VendorPatchEventParams struct {
	Pk      int32
	Wallet  string
	Column3 string
	Column4 string
	Column5 pgtype.Timestamp
	Column6 string
	Column7 string
	Column8 string
	Column9 string
}

func (q *Queries) VendorPatchEvent(ctx context.Context, arg VendorPatchEventParams) (AppEvent, error) {
	row := q.db.QueryRow(ctx, vendorPatchEvent,
		arg.Pk,
		arg.Wallet,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
	)
	var i AppEvent
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Venue,
		&i.Name,
		&i.Type,
		&i.EventDatetime,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
		&i.TransactionHash,
	)
	return i, err
}

const vendorPatchVenue = `-- name: VendorPatchVenue :one
update app.venue
set
  name = coalesce(nullif($3::text, ''), name),
  street_address = coalesce(nullif($4::text, ''), street_address),
  zip = coalesce(nullif($5::text, ''), zip),
  city = coalesce(nullif($6::text, ''), city),
  state_code = coalesce(nullif($7::text, ''), state_code),
  state_name = coalesce(nullif($8::text, ''), state_name),
  country_code = coalesce(nullif($9::text, ''), country_code),
  country_name = coalesce(nullif($10::text, ''), country_name),
  photo = coalesce(nullif($11::text, ''), photo)
where venue.pk = $1
  and venue.vendor = (
    select pk from app.vendor
    where wallet = $2
  )
returning pk, id, vendor, name, street_address, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo
`

type VendorPatchVenueParams struct {
	Pk       int32
	Wallet   string
	Column3  string
	Column4  string
	Column5  string
	Column6  string
	Column7  string
	Column8  string
	Column9  string
	Column10 string
	Column11 string
}

func (q *Queries) VendorPatchVenue(ctx context.Context, arg VendorPatchVenueParams) (AppVenue, error) {
	row := q.db.QueryRow(ctx, vendorPatchVenue,
		arg.Pk,
		arg.Wallet,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
	)
	var i AppVenue
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Name,
		&i.StreetAddress,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.StateName,
		&i.CountryCode,
		&i.CountryName,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
	)
	return i, err
}

const vendorRemoveEventPhoto = `-- name: VendorRemoveEventPhoto :one
update app.event
set photo = null
where event.id = $1
and event.vendor = (
    select pk from app.vendor
    where wallet = $2
)
returning pk, id, vendor, venue, name, type, event_datetime, description, disclaimer, basecost, num_unique, num_ga, photo, transaction_hash
`

type VendorRemoveEventPhotoParams struct {
	ID     uuid.UUID
	Wallet string
}

func (q *Queries) VendorRemoveEventPhoto(ctx context.Context, arg VendorRemoveEventPhotoParams) (AppEvent, error) {
	row := q.db.QueryRow(ctx, vendorRemoveEventPhoto, arg.ID, arg.Wallet)
	var i AppEvent
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Venue,
		&i.Name,
		&i.Type,
		&i.EventDatetime,
		&i.Description,
		&i.Disclaimer,
		&i.Basecost,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
		&i.TransactionHash,
	)
	return i, err
}

const vendorRemoveVenuePhoto = `-- name: VendorRemoveVenuePhoto :one
update app.venue
set photo = null
where venue.id = $1
and venue.vendor = (
    select pk from app.vendor
    where wallet = $2
)
returning pk, id, vendor, name, street_address, zip, city, state_code, state_name, country_code, country_name, num_unique, num_ga, photo
`

type VendorRemoveVenuePhotoParams struct {
	ID     uuid.UUID
	Wallet string
}

func (q *Queries) VendorRemoveVenuePhoto(ctx context.Context, arg VendorRemoveVenuePhotoParams) (AppVenue, error) {
	row := q.db.QueryRow(ctx, vendorRemoveVenuePhoto, arg.ID, arg.Wallet)
	var i AppVenue
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.Vendor,
		&i.Name,
		&i.StreetAddress,
		&i.Zip,
		&i.City,
		&i.StateCode,
		&i.StateName,
		&i.CountryCode,
		&i.CountryName,
		&i.NumUnique,
		&i.NumGa,
		&i.Photo,
	)
	return i, err
}
